# 前端编译及优化

## Javac编译过程

- 准备过程：初始化插入式注解处理器。

- 处理过程：

  ![](http://img.070077.xyz/typora_img/image-20220228121827151.png)

参考《编译原理》，此处略。

## 语法糖

###  类型擦除型泛型

与C#的“具现化性范型“不同，Java中的泛型只在程序源码中存在，在字节码时已替换为具体类型，无法当成真实类型使用。因此，对范型进行实例判断、创建泛型对象是不合法的行为。

*裸类型* ， 视为所有该泛型化实例的共同父类型。

# 后端编译与优化

## 即时编译器JIT

![](http://img.070077.xyz/typora_img/image-20220228215109712.png)

- 编译模式：代码编译为本地代码

- 解释模式：便于程序迅速启动

- 虚拟机可指定参数设置运行模式，默认为分层模式：

  - 第0层：程序纯解释执行，解释器不开启性能监控功能（`Profiling`）

  - 第1层：使用客户端编译器，进行简单可靠的稳定优化，不开启性能监控功能

  - 第2层：使用客户端编译器，开启方法及回边次数统计等有限性能监控功能

  - 第3层：使用客户端编译器，开启全部性能监控功能，出第2层的内容，还会

    收集分支跳转、虚方法调用版本等统计信息

  - 第4层：使用服务端编译器，会启动更多编译耗时更长的优化，且会根据监控信息进行一些不可靠的激进优化。

    ![](http://img.070077.xyz/typora_img/image-20220228215846774.png)

即时编译器编译的目标是“热点代码”方法体，即被多次调用的方法或循环体。（循环体的编译入口不同）。目前采用基于计数器的热点检测方案（还有一个主流方案是基于采样）

| ![](http://img.070077.xyz/typora_img/image-20220228220315587.png) | ![](http://img.070077.xyz/typora_img/image-20220228220341633.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

*回边* 的意思是在循环边界往回跳转。

方法调用计数器有半衰期，热度衰减动作由垃圾收集时顺便执行。

回边计数器没有衰减机制，统计值为绝对数字。

![](http://img.070077.xyz/typora_img/image-20220228220958077.png)（LIR：中间代码表示，SSA：静态单分派)

> 虚拟机在代码编译未完成时会按照解释方式继续执行，编译动作在后台的编译线程执行。

## 提前编译器

可以说是抛弃一些比较耗时的优化策略，选择替代方案，应用*过程内分析模拟* 和 *缓存加速* 作为实现方向。

即时编译器的优势在于：

-  性能分析制导优化
- 激进预测性优化
- 链接时优化

## 编译器优化技术

### 方法内联

方法内联被称为优化之母，除了消除方法调用的成本之外，更重要的意义是为其他优化手段建立良好的基础。

对于虚方法，Java虚拟机引入*类型继承关系分析* 技术CHA，确定虚方法的接口、类关系信息，如果只有一个方法版本则进行*守护内联* （假设只有这个版本）并预留继承关系发生变化时的回滚解释状态；若有多个版本，使用内联缓存方式。

### 逃逸分析

是目前Java虚拟机中比较前沿的优化技术，其基本原理是：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸；甚至可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸。

如果逃逸程度在线程逃逸之下（即不会被别的线程引用）：

- 栈上分配优化。使该对象在栈上分配内存，对应内存空间随栈帧出栈而销毁。
- 标量替换优化。标量指不可再分解的数据，如基本数据类型，否则称作聚合量。对于*方法逃逸之下* 的对象，可将对象的成员变量拆散为基本数据类型们，而不去创建对象体，在栈上分配与读写。
- 同步消除优化。关闭线程间同步措施。

### 公共子表达式消除

如果表达式 E 已经被计算过了，并且到现在 E 中所有变量的值都没有发生变化，那么 E 的此次出现就称为公共子表达式，是冗余的。

### 复写传播、无用代码消除

清除额外的变量、不会被执行的代码、无意义代码等。

### 数组检查边界消除

根据性能监控信息，相对于每次对数组索引的判断，使用隐式异常优化可减少开销，即：

虚拟机注册异常处理器`Segment Fault`，使用`try catch`机制代替`if else`机制。当然，由于越界需要进入中断异常处理，速度比判空慢。

# Java编译期优化分析

## String系列

```java
String s1 = "a";
String s2 = "b";
String s3 = "ab";
String s4 = s1 + s2;
/* 字符串拼接原理：临时StringBuilder(线程安全) -> toString */
String s5 = "a" + "b";//定值，编译期拼接。此时s3 == s5.
String s6 = new String("a") + new String("b");
String s5 = s5 + "c";//不会改变s4，值变化不影响原串
/* 【动态拼接的结果，不会放到常量池中】*/
sout(s3 == s4);//false
sout(s3 == s6);//false
```
