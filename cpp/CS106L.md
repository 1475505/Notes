# stream
`<<` `>>`到具体primitive type（自定义类型则重载运算符)，会识别到第一个invalid的字符，返回布尔值`!isFail`。其他的分割符包括：` ` `\n` 等。
![](http://img.070077.xyz/20221229022207.png)

Some Details:
- once an error is detected, the input stream’s `fail bit` is set, and it will no longer accept input。
- 如果你需要控制读入空格，使用`std::getline(istream& is, string& str, char delim)`， extracts but does not store delim。
- istream只接受`>>`，相对应ostream只支持`<<`

> Give any data type to the istringstream, it’ll store it as a string!


# STL
## bound
![](http://img.070077.xyz/20221230010609.png)
`lower_bound`：the smallest element strictly greater than(>) value
`upper_bound`：the smallest element greater or equal to (>=) value

## Iterators
(a type of pointer)
![](http://img.070077.xyz/20221230013802.png)

## Tricks
- `stable_partition`：满足条件的元素移到首部。保序
- Structured Binding
```cpp
auto p = std::make_pair("s", 5); 
auto [a, b] = p;
```

## const correctness
- We need to promise: a const(disallow modify) function calls const functions - need defining them as const functions.
```cpp
int Student::getAge() const { //just like `noexcept`
	return age;
}
const_iterator begin() const; // in .h, const interface
```
- read from right to left to understand:
`const int* a_const_ptr_to_int`;


# Class

Better than struct, 可见性语义。
![](http://img.070077.xyz/20230103232338.png)
An Object is an instance of a Class, with memory allocated. Use initializer lists for speedier construction!

## Template class
Templates don't emit code until instantiated, so include the .cpp in the .h instead of the other way around!
![](http://img.070077.xyz/20230103233835.png)
Sometimes, we need a name for a type that is dependent on our template types, such as iterators. So:
```cpp
// vector.h
template <typename T>
class vector { 
public: 
	using iterator = … // something internal like T* iterator begin(); 
}

// vector.cpp
typename vector<T>::iterator vector<T>::begin() {...}
// Before class specifier, iterator is a nested type in namespace vector::, so `typename` before line.
```

> **Type Aliases**
> You can use using type_name = type

**`std::optional<T>`** is a template class which will either contain a value of type T or contain nothing (expressed as nullopt)
```cpp
// if .back() returns an optional...
std::optional<valueType> vector<valueType>::back(){
	if(empty()){ return {}; }
	return *(begin() + size() - 1);
}

std::optional<Student> output = find(..);
if (output.has_value()) { // actually can simplify to `output`
	cout << output.value().name << endl;
}
```
## Template Functions
We can also implicitly return value for the compiler to deduce.(same for call)
```cpp
template <typename T, typename U>
auto smarterMyMin(T a, U b) {
	return a < b? a : b;
}

// lambda function
auto lambda_min = [a, b] (auto a, auto b) auto {return a < b? a : b;}
```

Actually lambda is:
`[capture-closure]`: like `[&]` for catch all as reference, `[=]` as value.

>**Functor**：
 is any class that provides an implementation of operator `()` 

## Operators
- Non-member overloading:
`bool operator< (const Student& lhs, const Student& rhs);`
- Membered overloading:
with `friend` keyword, allows non-member functions or classes to access private information in another class!
`friend bool operator < (const Student& lhs, const Student& rhs) const;`


# Special Member Functions
There are six special member functions!
```cpp
class widget {
public:
	Widget();// default constructor
	Widget (const Widget& w);// copy constructor
	Widget& operator = (const Widget & w); // copy assignment operator
	~Widget();//destructor
	Widget (Widget&& rhs);//move constructor
	Widget & operator = (Widget&& rhs);// move assignment operator
```

For `=default`, keep same
For `=0`, must define new ones.

> THE RULE OF:
> 0: if compiler works fine, don't define your own!
> 3: have to define a destructor, copy constructor, or copy assignment operator
> 
## LValue and RValue
*l-values* can appear on the left or right of an =, have names and are **not temporary**.
*r-values* can ONLY appear on the right, have no name and **is temporary**. 右值不可被直接`&`来传参。

`=` automatically makes a copy! Must use & to avoid this.

## Copy and Move
Copying isn’t always simple! 
> Deep copy: an object that is a complete, independent copy of the original

Move constructors and move assignment operators will perform "memberwise moves", which uses for R-value reference.

# Smart Pointers
> Pointers Protocol
> RAII: Resource Acquisition is Initialization (like 2PC)

- `unique_ptr`：Uniquely owns its resource, can't be copied
- `shared_ptr`：Can make copies, destructed when underlying memory goes out of scope（reference_count）
> Always use `std::make_unique<T>` and `std::make_shared<T>`!
- `weak_ptr`：Models temporary ownership: when an object only **needs to be accessed if it exists** (convert to shared_ptr to access)
> 指向一个由 shared_ptr 管理的对象而不影响所指对象的生命周期，也就是将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数，以处理循环引用的问题。


# 模板元编程
可以理解为，对`type`进行编程。
```cpp
using S = int; // just like typedef
using cl_ref = const S&;
using result = std::remove_reference<cl_ref>::type;
constexpr bool equals = std::is_same<result,const int>::value;
if constexpr(equals) {
	go die;// Don't compile if equals is false
}
```

## 元函数
A meta-function is a *struct* that has *public* member types/fields which depend on **what the template types/values are instantiated with**.
![](http://img.070077.xyz/20230102222243.png)
如，返回“输入”：
![](http://img.070077.xyz/20230102222523.png)
> `static`，因为我们不需要实例化此`struct`。

## 模板特化
`template <[un-specified types]> class vector<bool>[specified types] {};`
> 编译器会根据具体度降序判断是哪个特化的模板。

# Concept(since C++20)