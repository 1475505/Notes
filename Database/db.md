# 数据库基础知识

## 三大范式五大约束

数据库的三大特性：实体、属性、关系。

### 三大范式

第一范式（1NF）：数据表中的每一列（属性）必须是不可拆分的最小单元，也就是确保**每一列的原子性**。

第二范式（2NF）：满足1NF后，要求表中的**所有列，都必须依赖于主键**，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情，消除了非主属性对于码的部分函数依赖（商品+供应商）。

![2NF](http://img.070077.xyz/202202140406172.png)

第三范式（3NF）：满足2NF后，要求表中的每一列只与主键直接相关而不是间接相关（只依赖于主键），即要求分成多张表，**一张表中只能有另一张表中的id（主键），而不能包含其他信息**（由主键在另一表查询）。反例：关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，存在非主属性系主任对于学号的传递函数依赖。

### 五大约束

1. primary KEY 主键约束(primary key = unique + not null)
2. UNIQUE 设置唯一性约束，不能有重复值；
3. DEFAULT 默认值约束，height DOUBLE(3,2)DEFAULT 1.2 height不输入是默认为1.2
4. NOT NULL：设置非空约束，该字段不能为空；
5. FOREIGN key :设置外键约束。

## SQL

我们通常可以将SQL分为三类：

- DDL（数据定义语言）

  主要用于创建（create）、删除（drop）、修改（alter）数据库中的对象。

- DML（数据操作语言）

  主要负责插入数据（insert）、删除数据（delete）、更新数据（update）和查询（select）。

- DCL（数据控制语言）。

  主要用于授予权限（grant）和召回权限（revoke）。
  
## 可持久化数据结构

B+树

# MySQL开发
  
![](http://img.070077.xyz/202205060138717.png)


## 存储引擎

### MyISAM 和 InnoDB

两种类型最主要的差别就是 **Innodb 支持事务处理与外键和行级锁**。

> 事务（transaction）是用户定义的一批数据库操作，这些操作要么全执行，要么完全不执行.

InnoDB作为MySQL5.5之后的默认存储引擎（MySQL8.0将所有系统表也改为InnoDB），提供了具有提交、回滚和崩溃恢复能力的*事务安全保障*，同时提供了更小的*锁粒度*（完整支持行锁）和*MVCC高并发*支持，支持真正的在线*热备份*，拥有独立的缓存和日志，性能有较大的提升。对比MyISAM存储引擎，InnoDB会占用更多的磁盘空间以保留数据和索引。

### InnoDB 的特点

- 自动增长列：

  可以通过`ALTER TABLE ** AUTO_INCREMENT=...;`语句强制设置自动增长列的初始值，默认从1开始.（MySQL8.0之前版本的BUG：对于InnoDB存储引擎来说，这个值只保留在内存中，重启数据库会丢失此值）。

- 外键约束

- 主键和索引

  不同于其他存储引擎，InnoDB的数据文件的保存方式本身就是聚簇索引（索引结构和数据一起存放的索引），即索引也是InnoDB表的主键，表的每行数据都保存在主索引的叶子节点上。因此，所有InnoDB表都必须包含主键（否则会自动创建long类型隐藏字段作为主键）。建议所有InnoDB表都应如下**显式**地指定主键：

  - 优先考虑使用最经常被当作*查询条件*的字段或者自增字段；
  - 字段值基本不会被修改；
  - 使用尽可能短的字段。

### 其他存储引擎

- MEMORY

  MEMORY的表对应一个`frm`文件，数据以哈希索引放在内存中，若服务关闭会丢失数据。主要用于那些内容变化不频繁的代码表，或者作为统计操作的中间结果表。

- MERGE

  MERGE存储引擎也被称为MRG_MyISAM，是一组同结构MyISAM表的组合。MERGE表本身并没有数据。会有时间记录操作日志表。

- TokuDB

  非常优秀的存储引擎。高效的插入性能、优秀的压缩特性（比InnoDB高近10倍）、热编辑和BulkLoader快速加载大量数据、主从延迟消除、支持ACID和MVCC。适合：日志（插入频繁）、历史（高压缩）、频繁在线DDL。

## 数据类型建议

- 使用VARCHAR

由于CHAR是固定长度的，可能浪费存储空间（程序需要对行尾空格进行处理），除非是长度稳定且高查询速度要求，建议使用**按需长度**的VARCHAR。

- 减少BLOB(支持二进制)和TEXT的使用，使用时分离到单独表

  减小主表的碎片，使得检索比较稳定。

- 如果需要高精度存储，使用定点数DECIMAL

  其本质上是字符串。

- 除非年份跨度大，优先使用TIMESTAMP

  日期类型中*只有* 它能够和实际时区相对应。

- 优先选择满足存储需要的最小的数据类型

## 索引设计和使用

索引是一种用于快速查询和检索数据的数据结构。相当于目录。将对应的全盘扫描减少至对数级。注意：过度索引会导致写性能的损失，且索引需要占用一定的磁盘空间。

语法：

```sql
CREATE [ UNIQUE / FULLTEXT / SPATIAL ] INDEX index_name [index_type]
ON tbl_name(index_col_name,...)
[index_option][algorithm_option/Tock_option]... -- [INVISIABLE]

index_col_name:
	col_name [(length)][ASC/DESC]
```

索引的设计原则：

1. 最适合索引的列是出现在*WHERE子句和连接子句*中的**条件列**，而非查询列。
2. 尽量使用唯一索引。索引列的基数越大（重复值少），索引的效果就越好。二级索引的叶子节点存放的是主键值，而不是实际数据。
3. 使用短索引、数据类型较短的索引。如：前缀索引，取VARCHAR(100)的(10)。另，InnoDB存储引擎，表的索引都会保存主键的值，为减少索引占用的空间，提升缓存效果，建议显式指定主键。
4. 使用最左前缀。若有多列联合索引，最左索引是优先级最高的索引，如联合索引`(c1,c2,c3)`，实际相当于建了 `(c1)`，`(c1,c2)`，`(c1,c2,c3)` 三个索引，不可进行`c2`索引查询。这样可减少索引占用的空间。


> 有一个比较特殊的查询条件：`where c1 = 1 and c3 = 3 ，符合最左匹配吗？

这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。
MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，然后再比对 c 字段的值。
从 MySQL5.6 之后，有一个**索引下推功能**，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

### 索引失效

当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效。**因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。**

在查询条件中对索引进行函数、表达式计算，也是无法走索引的，因为索引存储的是原数据。同样地，类型转换也可能导致索引失效。

### 索引下推(ICP)

在**非主键索引**上的优化。

在没有使用ICP的情况下，MySQL的查询：

-   存储引擎读取索引记录；
-   根据索引中的主键值，定位并读取完整的行记录；
-   存储引擎把记录交给`Server`层去检测该记录是否满足`WHERE`条件。

使用ICP的情况下，查询过程：

-   存储引擎读取索引记录（不是完整的行记录）；
-   **判断`WHERE`条件部分能否用索引中的列来做检查**，条件不满足，则处理下一行索引记录；
-   条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；
-   存储引擎把记录交给`Server`层，`Server`层检测该记录是否满足`WHERE`条件的其余部分。

## 事务处理

事务（transaction）：指一组SQL语句。

### ACID
- 原子性（Atomicity): 事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
- 一致性（Consistent): 在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
- 隔离性（Isolation):数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
- 持久性（Durable):事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。
---

- 回退（rollback）：撤销指定SQL语句的过程，只能在一个事务处理内使用
- 提交（commit）：将未存储的SQL语句结果写入数据库表
- 保留点（savepoint）：事务处理中设置的临时占位符（place-holder）你可以对它发布回退（与回退整个事务处理不同）

### 事务处理

并发事务带来的问题有：

- 更新丢失（Lost Update):当两个或多个事务选择同一行进行更新，最后的更新覆盖了由其他事务所做的更新。
- 脏读（Dirty Read):一个事务正在对一条记录做修改，在这个事务完成并提交前，另一个事务也来读取同一条记录，第二个事务读取了这些未提交的“脏”数据，并据此做进一步的处理，产生未提交的数据依赖关系。
- 不可重复读（Non-Repeatable Read):一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变或某些记录已经被删除。
- 幻读（Phantom Read):一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据的现象。

### 事务隔离级别

![](http://img.070077.xyz/202204191144630.png)

### MVCC

对于「已提交读」和「可重复读」隔离级别的事务来说，它们是通过 Read View 快照来实现的，区别在于创建 Read View 的时机不同，**「已提交读」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。** 这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。

![](http://img.070077.xyz/202204231538385.png)

> 快照读：读取数据的可见版本（旧版本），不加锁，如`select`
> 当前读：读取数据的最新版本（当前版本），加锁


### 分布式事务

分布式事务应用程序包含一个或多个资源管理器和事务管理器。

- 资源管理器（RM）：提供通向事务资源的途径。
- 事务管理器（TM）：用于协调作为一个分布式事务一部分的事务。TM与管理每个事务的RMs进行通信。

用于执行分布式事务的过程使用两阶段提交（2pC）：

- 在第一阶段中，所有的分支被预备好。即它们被TM告知要准备提交。RM会记录分支的行动指示。
- 在第二阶段中，TM告知RMs是否要提交或回滚。如果在预备分支时，所有的分支指示它们将能够提交，则所有的分支被告知要提交。如果在预备时，有任何分支指示它将不能提交，则所有分支被告知回滚。

分布式事务（XA事务）的SQL语法如下：

`XA {START/BEGIN} xid [JOIN/RESUME]`

每个XA事务必须有一个唯一的标识xid值，以区分事务。

```sql
XA END xid [SUSPEND [FOR MIGRATE]]
XA PREPARE xid -- 使事务进入PREPARE状态，也就是两阶段提交的第一个提交阶段。
XA COMMIT xid [ONE PHASE]
XA ROLLBACK xid -- 这两个命令用来提交或者回滚具体的分支事务,也就是两阶段提交的第二个提交阶段：分支事务被实际提交或者回滚。
XA RECOVER -- 返回当前数据库中处于PREPARE状态的分支事务的详细信息。
```

### 分布式简介

留坑：MIT6.824

## SQL注入简介

个人理解是，URL传值中包含SQL标识或语句（/*…），导致处理异常。

解决方案是：绑定变量（正常转义），验证机制。

# MySQL优化

## 优化工具

我们可以通过以下操作了解哪些SQL语句执行频率高。

查看表：`show status [condition]`

> `explain + SQL语句`可以得到该SQL语句的执行步骤。
>
> 返回的`type`值表示效率由低到高从ALL/INDEX/RANGE到CONST/SYSTEM/NULL


## 锁设计

MySQL有3种锁。
- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。适合查询为主的应用。
  - 表共享读锁：阻塞写请求。
  - 表独占写锁：优先获得。
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。适合在线处理系统，即大量按索引条件更新的数据、并发查询。
  - 共享锁（S):允许一个事务**读**一行，阻止其他事务获得相同数据集的排他锁。
  - 排他锁（X):允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Lock),这两种意向锁都是表锁。
- 意向共享锁（IS):事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
- 意向排他锁（IX):事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

InnoDB行锁是通过给索引上的**索引项加锁**来实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来对记录加锁。
InnoDB行锁分为3种情形：
- Record lock:对索引项加锁。
- Gap lock:对索引项之间的“间隙”、第一条记录前的“间隙”或最后一条记录后的“间隙”加锁。
- Next-key lock:前两种的组合，对记录及其前面的间隙加锁。

InnoDB这种行锁实现特点意味着：如果**不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁**，实际效果跟表锁一样。

## IO设计

# MySQL管理

## 日志

支持事务的数据库系统都需要有一套机制来保证事务更新的一致性和持久性。原子性、一致性、持久性通过数据库的redo log和undo log来完成。
- redo log称为重做日志，用来保证事务的原子性和持久性。
- undo log称为回滚日志，记录修改前的数据，用来保证事务的一致性，用于MVCC快照读。
- redo恢复提交事务修改的页操作，而undo回滚行记录到某个特定版本
- redo通常是物理日志，记录的是页的物理修改操作。undo是逻辑日志，根据每行记录进行记录。

## 备份

---
参考：
[小林coding (xiaolincoding.com)](https://www.xiaolincoding.com/)
《MySQL技术内幕 InnoDB存储引擎》
《深入浅出MySQL数据库开发、优化与管理维护》


