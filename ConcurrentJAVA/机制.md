# 底层实现原理复习

![](http://img.070077.xyz/202203162218610.png)

## volatile

实现原则：

- 通过`lock`前缀指令，引起处理器缓存写回内存。（锁总线）
- 一个处理器的缓存写回内存，会导致其他处理器的缓存无效。（轮询）

## synchronized

- 对于普通同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的Class对象。
- 对于同步方法块，锁是Synchonized括号里配置的对象。

## 原子操作

![不可分割的操作](http://img.070077.xyz/202203162343291.png)

如何保证原子性呢？

- 处理器的总线锁、缓存锁。

如何实现原子操作呢？

- 自旋CAS

  存在三个问题：

  - ABA死锁 -> 每次更新加版本号
  - 循环时间长，开销大
  - 只能保证一个共享变量的原子操作

- 使用锁机制

## 锁

JVMTEP - 2 中简单带过了对象头机制，以下开始认识之。

![可见，数组类型对象头为3字宽，否则为2](http://img.070077.xyz/202203162248498.png)

Java对象头里的MarkWord里默认存储对象的HashCode、分代年龄和锁标记位。

![32bit情况](http://img.070077.xyz/202203162328194.png)

![64-bit情况](http://img.070077.xyz/202203162300466.png)

我们来认识这些锁级别。

### 偏向锁

研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由**同一线程**多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，对应线程不需要进行CAS（compare and swap）操作。

![全局安全点](http://img.070077.xyz/202203162304324.png)

### 轻量级锁

多个线程交替进入临界区。**只需要依靠一条CAS原子指令就可以完成锁的获取及释放**。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒。

![](http://img.070077.xyz/202203162309481.png)

由于自旋存在CPU的空转，若存在多个自旋线程，则升级为重量级锁，由操作系统monitor统一管理。

![](http://img.070077.xyz/202203162340578.png)

### 双重检查锁定

这也是单例模式的代码：

```java
public class DoubleCheckedLocking(
	private static Instance instance;
	public static Instance getInstance()(
		if (instance==null){
			synchronized(DoubleCheckedLocking.class)(
				if (instance==null)
					instance=new Instance();
return instance;
```

-> 初始化和设定对象分配的地址指令重排，则会导致对象未初始化。

![线程 B 将会访问到一个还未初始化的对象 。](http://img.070077.xyz/202203220143825.png)

解决方案1：把`instance`声明为`volatile`

`private volatile static Instance instance ;`

解决方案2：延迟类初始化方案

```java
public class InstanceFactory (
	private static class InstanceHolder {
		public static Instance instance = new Instance();
	}
	public static Instance getInstance(){
		return InstanceHolder.instance;//这里将导致InstanceHolder类被初始化
    }
}
```

其中第6行满足类初始化（还记得吗，“万不得已”时）的条件：

- 类中声明的一个静态字段被使用，而且这个字段不是一个常量字段。

实质：允许非构造线程（这里指线程 B)“看到“这个重排序。

![不允许非构造线程（这里指线程 B)“看到“这个重排序](http://img.070077.xyz/202203220351654.png)

下面我们来看JVM类初始化的同步处理机制，五步：

1. 通过在 Class 对象上同步（即获取 Class 对象的初始化锁），来控制类或接口的初始化。这个获取锁的线程会一直等待，**直到当前线程能够获取到这个初始化锁** 。

2. 线程 A 执行类的初始化，同时线程 B 在初始化锁对应的 condition 上等待 。

   ![](http://img.070077.xyz/202203220351711.png)

3. 线程 A 设置 state = initialized, 然后唤醒在 condition 中等待的所有线程 。

4. 线程 B 结束类的初始化处理 。

   这个 happens-before 关系将保证：线程 A 执行类的初始化时的写入操作（执行类的静态初始化和初始化类中声明的静态字段），线程 B 一定能看到 

5. 线程 C 执行类的初始化的处理。

   happens-before 关系将保证：线程 A 执行类的初始化时的写入操作，线程 C 一定能看到 。

   ![](http://img.070077.xyz/202203220354884.png)

# 线程池技术系列

