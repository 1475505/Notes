# 并发编程简单复习

![](http://img.070077.xyz/202203162218610.png)

## volatile

实现原则：

- 通过`lock`前缀指令，引起处理器缓存写回内存。（锁总线）
- 一个处理器的缓存写回内存，会导致其他处理器的缓存无效。（轮询）

## synchronized

- 对于普通同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的Class对象。
- 对于同步方法块，锁是Synchonized括号里配置的对象。

## 原子操作

![不可分割的操作](http://img.070077.xyz/202203162343291.png)

如何保证原子性呢？

- 处理器的总线锁、缓存锁。

如何实现原子操作呢？

- 自旋CAS

  存在三个问题：

  - ABA死锁 -> 每次更新加版本号
  - 循环时间长，开销大
  - 只能保证一个共享变量的原子操作

- 使用锁机制

## 锁

JVMTEP - 2 中简单带过了对象头机制，以下开始认识之。

![可见，数组类型对象头为3字宽，否则为2](http://img.070077.xyz/202203162248498.png)

Java对象头里的MarkWord里默认存储对象的HashCode、分代年龄和锁标记位。

![32bit情况](http://img.070077.xyz/202203162328194.png)

![64-bit情况](http://img.070077.xyz/202203162300466.png)

我们来认识这些锁级别。

### 偏向锁

研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由**同一线程**多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，对应线程不需要进行CAS（compare and swap）操作。

![全局安全点](http://img.070077.xyz/202203162304324.png)

### 轻量级锁

多个线程交替进入临界区。**只需要依靠一条CAS原子指令就可以完成锁的获取及释放**。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒。

![](http://img.070077.xyz/202203162309481.png)

由于自旋存在CPU的空转，若存在多个自旋线程，则升级为重量级锁，由操作系统monitor统一管理。

![](http://img.070077.xyz/202203162340578.png)

### 双重检查锁定

这也是单例模式的代码：

```java
public class DoubleCheckedLocking(
	private static Instance instance;
	public static Instance getInstance()(
		if (instance==null){
			synchronized(DoubleCheckedLocking.class)(
				if (instance==null)
					instance=new Instance();
return instance;
```

-> 初始化和设定对象分配的地址指令重排，则会导致对象未初始化。

![线程 B 将会访问到一个还未初始化的对象 。](http://img.070077.xyz/202203220143825.png)

解决方案1：把`instance`声明为`volatile`

`private volatile static Instance instance ;`

解决方案2：延迟类初始化方案

```java
public class InstanceFactory (
	private static class InstanceHolder {
		public static Instance instance = new Instance();
	}
	public static Instance getInstance(){
		return InstanceHolder.instance;//这里将导致InstanceHolder类被初始化
    }
}
```

其中第6行满足类初始化（还记得吗，“万不得已”时）的条件：

- 类中声明的一个静态字段被使用，而且这个字段不是一个常量字段。

实质：允许非构造线程（这里指线程 B)“看到“这个重排序。

![不允许非构造线程（这里指线程 B)“看到“这个重排序](http://img.070077.xyz/202203220351654.png)

下面我们来看JVM类初始化的同步处理机制，五步：

1. 通过在 Class 对象上同步（即获取 Class 对象的初始化锁），来控制类或接口的初始化。这个获取锁的线程会一直等待，**直到当前线程能够获取到这个初始化锁** 。

2. 线程 A 执行类的初始化，同时线程 B 在初始化锁对应的 condition 上等待 。

   ![](http://img.070077.xyz/202203220351711.png)

3. 线程 A 设置 state = initialized, 然后唤醒在 condition 中等待的所有线程 。

4. 线程 B 结束类的初始化处理 。

   这个 happens-before 关系将保证：线程 A 执行类的初始化时的写入操作（执行类的静态初始化和初始化类中声明的静态字段），线程 B 一定能看到 

5. 线程 C 执行类的初始化的处理。

   happens-before 关系将保证：线程 A 执行类的初始化时的写入操作，线程 C 一定能看到 。

   ![](http://img.070077.xyz/202203220354884.png)

# 并发编程实例概览

## `ThreadLocal`的使用

通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。`ThreadLocal`类使得每一个线程都有自己的**专属**本地变量，只能被当前线程访问，其他线程无法访问和修改。`ThreadLocal`支持泛型，以 `ThreadLocal` 对象为键、任意对象为值。这个存储结构附带在线程上，也就是说一个线程可以根据键对象查询到绑定在这个线程上的专属值。可用于：订单ID等。

可以通过`set(T)`方法来设置这个值，在当前线程下再通过`get()`方法获取到原先设置的值。第一次`get`方法调用时会进行初始化（如果 set 方法没有调用）。 

```java
private static final ThreadLocal<Long> TIME_THREADLOCAL = new ThreadLocal<Long>() {
    @Override
	protected Long initialValue(){ //重写initialValue方法为ThreadLocal设置默认的get初始值
		return System.currentTimeMillis();
};
```

### 如何实现？

实际上，`ThreadLocal`的值是放入了当前线程的一个`ThreadLocalMap`实例中，所以只能在本线程中访问。

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);//return t.threadLocals;
    /*
    class Thread implements Runnable {
    	ThreadLocal.ThreadLocalMap threadLocals = null;
	}
	*/
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);//t.threadLocals = new ThreadLocalMap(this, firstValue);
}
```

### 底层分析

因为`ThreadLocal`实例实际上也是被其创建的类持有（更顶端应该是被线程持有）。而`ThreadLocal`的值其实也是被线程实例持有。**它们都是位于堆上，只是通过一些技巧将可见性修改成了线程可见。**

ThreadLocal*正确使用*并不会产生内存泄露，因为ThreadLocalMap在选择key的时候，并不是直接选择ThreadLocal实例，而是ThreadLocal实例的弱引用。不过…使用完 `ThreadLocal`方法后，建议最好手动调用`remove()`方法。

```java
static class ThreadLocalMap {
/**
* The entries in this hash map extend WeakReference, using
* its main ref field as the key (which is always a
* ThreadLocal object).  Note that null keys (i.e. entry.get()
* == null) mean that the key is no longer referenced, so the
* entry can be expunged from table.  Such entries are referred to
* as "stale entries" in the code that follows.
*/
    static class Entry extends WeakReference<ThreadLocal<?>> {     
        Object value;/** associated with this ThreadLocal. */
        Entry(ThreadLocal<?> k, Object v) {
            super(k);
            value = v;
        }
    }
}
```

## 池化技术

### 线程池

线程池技术能够很好地解决频繁的短小任务时的线程开销问题，它预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行 。一方面，消除了频繁创建和消亡线程的系统资源开销，另一方面，面对过量任务的提交能够平缓劣化。

```java
public interface ThreadPool<Job extends Runnable>{
	void execute(Job job);//执行一个Job,这个Job需要实现Runnable
	void shutdown();//关闭线程池
	void addworkers(int num);//增加工作者线程
	void removeWorker(int num);//减少工作者线程
	int getJobSize();//得到正在等待执行的任务数量
}//这里工作者线程代表着一个重复执行 Job 的线程，
//每个由客户端提交的Job 都将进入到一个工作队列中等待工作者线程处理。
```

下文将详述线程池。

![线程池技术带来服务器吞吐量的提高](http://img.070077.xyz/202203281358578.png)

# JUC

本章介绍 Java 并发包中相关的 API 和组件，以及这些 API 和组件的使用方式和实现细节。

## 锁

### Lock接口

Lock 接口出现之前，Java 程序是靠 synchronized 关键字实现锁功能的，而 Java SE 5 之后，并发包中新增了 Lock 接口（以及相关实现类）用来显式实现锁功能。

```java
Lock lock = new ReentrantLock();
lock.lock();
try {...} finally {lock.unlock();}
```

![](http://img.070077.xyz/202203290034087.png)

### 队列同步器

`AbstractQueuedSynchronizer` （简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个 int 成员变量表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的排队工作。子类通过继承同步器并实现它的抽象方法来管理同步状态，使用同步器提供的 3 个方法 getState 、setState(int newState) 和 compareAndSetState(int expect, int update) 控制状态。

